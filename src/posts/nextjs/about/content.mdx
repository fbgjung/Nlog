---
title: "Next.js가 뭔가요?"
date: 2025-04-14
desc: NextJS가 뭘까용
thumbnail: /posts/nextjs/about/thumbnail.jpeg
---

<Callout>
React로도 충분히 개발할 수 있는데, NextJS는 왜 필요할까요?
</Callout>

## 1. React VS NextJS

<span className="text-gray-500">
NextJS는 SSR(Server Side Rendering)로 로드가 정말 빠르다는 장점이 있지만
많은 것을 자동화하여 개발 경험을 최상으로 이끌어주는 프레임워크이기도 합니다.

React는 라이브러리이고, NextJS는 프레임워크인데요.
라이브러리와 프레임워크의 차이는 무엇일까요?
</span>


### [1] 라이브러리
<span className="text-gray-500">
개발자가 주도권을 가지고 필요한 기능을 가져다 사용합니다.
- 아키텍처를 직접 설계하고 파일 구조나 코드 스타일도 마음대로 결정할 수 있습니다.
- 필요한 순간에만 라이브러리를 불러와서 사용하면 됩니다.
- 예를 들어, React는 사용자 인터페이스(UI)를 구축하기 위한 라이브러리입니다.
- React는 컴포넌트를 통해 UI를 구성하는 데 도움을 줄 뿐, 전체 프로젝트 구조를 강요하지 않습니다.
</span>

### [2] 프레임워크
<span className="text-gray-500">
프레임워크가 주도권을 가지고 코드를 사용합니다.
- 여러 가지 결정을 개발자 대신해주고 자동화하도록 할 수 있습니다.
- 프로젝트를 시작하면 프레임워크가 코드를 찾아서 실행합니다.
- 그리고 그 코드를 올바른 위치에 배치하고, 함수에 올바른 이름을 지정하고, 변수를 올바른 모양으로 export하여 웹사이트를 구축합니다.
</span>

<hr />

## 2. 폴더 구조 / 라우팅은 어떻게 처리할까요?
<Callout>
React는 react-router로 직접 설정해 주어야 했지만
NextJS에서는 파일 기반 라우팅으로 간편하게 처리할 수 있어요.
규칙만 잘 지켜준다면, 정말 쉽게 NextJS가 제공하는 기능들을 사용하여 렌더링 할 수 있습니다.
</Callout>

### [1] React-Router
- NextJS 사용 전에는 React-Router를 사용했을 거에요.
- React-Router는 개발자가 직접 URL을 지정하고 컴포넌트 렌더링을 요청하는 것입니다.

```tsx
// src/App.tsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import HomePage from "./pages/HomePage";
import DaisyPage from "./pages/DaisyPage";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/daisy" element={<DaisyPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### [2] App Router: 디렉토리 이름 + page.tsx
- NextJS 라우팅은 개발자가 URL을 지정하지 않아도 됩니다. 폴더 시스템으로 라우팅을 할 수 있어요.
- 반드시 page.tsx 라는 이름을 파일로 경로의 마지막에 위치해야 합니다.
- NextJS가 파일을 자동으로 감지하여 URL과 매칭합니다.
- 이때 app/page 는 root segment로 유저가 제일 먼저 root("/") 에서 보게될 페이지를 의미합니다.
```bash
app/
  page.tsx        👉 '/'
  daisy/
    page.tsx      👉 '/daisy'
```

### [3] Route Groups
- 폴더명을 괄호로 감싸면 해당 경로를 URL 경로에 포함시키지 않고 구조화할 수 있어요.
- 폴더 구조를 관리하기에 유용합니다.

```bash
app/
  (main)/
    nextjs/
      page.tsx   👉 '/nextjs'
```

### [4] Dynamic Routing
- 대괄호를 사용하여 원하는 이름으로 dynamic URL을 만들 수 있어요.
```bash
app/
  blog/
    [category]/
      [slug]/
        page.tsx   👉 '/blog/nextjs/about'
```

### [5] layout.tsx
- 여러 페이지에서 공통적으로 사용되는 UI 요소들을 관리할 때 유용합니다.
- 예를 들어, 헤더, 푸터, 사이드바 같은 요소들이 여러 페이지에서 반복될 경우 layout.tsx 파일에 정의하여 모든 페이지에서 공유할 수 있습니다.
- page.tsx 처럼 경로와 파일명을 꼭 지켜야합니다.

```tsx
// app/layout.tsx
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div>
      <Header />
      <main>{children}</main>
      <Footer />
    </div>
  );
}
```
```tsx
// app/page.tsx
export default function HomePage() {
  return <h1>홈페이지</h1>;
}
````
HomePage는 layout.tsx에 정의된 레이아웃을 사용하게 됩니다.

### [6] not-found.tsx
- 유저가 존재하지 않는 URL로 접근 할 때 자동으로 렌더링되는 페이지를 정의합니다.
- 주로 404 페이지로 사용됩니다.
- page.tsx 처럼 경로와 파일명을 꼭 지켜야합니다.
```tsx
// app/not-found.tsx
export default function NotFound() {
  return (
    <div>
      <h1>페이지를 찾을 수 없습니다!</h1>
    </div>
  );
}
```

<hr />

## 3. SSR vs CSR
<Callout>
브라우저에서만 렌더링 하던 걸 서버에서도 하게 되면 어떤 점이 더 좋아질까요?
</Callout>

### [1] SSR(Server Side Rendering)
- NextJS SSR(Server Side Rendering)로 웹사이트를 빌드합니다.
- 브라우저는 JavaScript가 로드될 때까지 기다릴 필요가 없습니다.
- 그렇기 때문에 JavaScript가 활성화 되어있지 않아도 유저는 HTML을 볼 수 있어요.
- <span className="text-indigo-500">nextJS는 어플리케이션의 모든 page의 컴포넌트들을 우선 서버에 렌더링 합니다.</span>

### [2] CSR(Client Side Rendering)
- React는 CSR(Client Side Rendering)로 웹사이트를 빌드합니다.
- 유저가 웹 페이지에 도착한 시점에는 JavaScript를 기다려야 하기 때문에 HTML에 실제 소스코드는 비어있습니다.
- 즉, 브라우저가 모든 JavaScript 파일을 다운로드하고 실행한 후에야 화면이 보이게 됩니다.
- 그렇기 때문에 JavaScript를 비활성화하면 화면이 나오지 않아요. 또 초기 로딩이 느릴 수 있습니다.
- 로딩이 느리기 때문에 SEO도 자연스럽게 불리해집니다.

### [3] Hydration & "use client"
NextJS page.tsx의 컴포넌트는 기본적으로 서버 컴포넌트입니다.
여기서 주의해야할 점은 "use client" 키워드가 있어도 서버 컴포넌트라는 점이에요.
해당 키워드가 있다면 단순 HTML을 hydration을 적용하여 CSR 앱으로 초기화하는 과정을 거치게됩니다.
즉, 컴포넌트가 interactive하게 하는 과정입니다.

이렇게 키워드를 통해 구분하기 때문에 렌더링시 다운 받을 JavaScript의 양이 적어짐을 의미하기도 합니다.
"use client"가 없는 컴포넌트는 JavaScript 코드를 다시 다운로드할 필요가 없으니까요.

### [4] 정리
1. NextJS 서버에서 애플리케이션을 pre-rendering합니다.
2. 모든 컴포넌트를 interactive 하지않은 HTML로 바꾸어 사용자에게 보여줍니다.
3. "use client" 명령어를 가진 컴포넌트가 클라이언트에서 hydrate되고 interactive 해집니다.
4. 서버 컴포넌트 안에 클라이언크 컴포넌트를 가질 수 있지만 그 반대는 불가능합니다.


<hr />

## 4. Metadata
<Callout>
NextJS에서는 SEO를 어떻게 챙길까요?
</Callout>
### [1] 특징
- 꼭 내보내야 하는 객체입니다.
- 페이지의 헤더, 탭에 표시되는 데이터입니다.
- 페이지나 레이아웃만 메타데이터를 내보낼 수 있습니다.
- 컴포넌트에서는 메타데이터를 내보낼 수 없습니다.

### [2] 작성 방법
```tsx
export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
}
```

<img src="/posts/nextjs/about/metadata1.png" alt="브라우저 탭에 반영된 title"/>
- 브라우저 탭에 반영된 title
<img src="/posts/nextjs/about/metadata2.png" alt="HTML head에 반영된 metadata"/>
- HTML head에 반영된 metadata


<hr />

## 5. Data Fetching
<Callout>
NextJS에서는 서버에서 데이터를 바로 불러올 수 있습니다.
</Callout>

### [1] React
React에서는 useEffect, useState, fetch로 데이터를 불러오곤 했습니다.
- 개발자는 로딩 상태를 구현해야 합니다.
- 데이터 fetch는 항상 클라이언트에서 일어납니다.
- API 호출이 일어납니다.
- metadata를 쓸 수 없게 됩니다.
```tsx
"use client"
import { useEffect, useState } from "react";

export default function Tomato() {
  const [isLoading, setIsLoading] = useState(true);
  const [movies, setMovies] = useState([]);

  const getMovies = async () => {
    const response = await fetch("https://movie.com");
    const json = await response.json();
    setMovies(json);
    setIsLoading(false);
  };

  useEffect(() => {
    getMovies();
  }, []);

  return <div>{isLoading ? "Loading..." : JSON.stringify(movies)}</div>;
}
```

### [2] NextJS
NextJS 백엔드가 API 없이 직접 데이터베이스와 통신할 수 있다면? 서버 컴포넌트에서 fetch를 사용하게 된다면?
- useEffect, useState를 쓰지 않아도 됩니다.
- 로딩 상태를 개발자가 구현할 필요가 없습니다.
- 프레임워크가 대신 해주기 때문에 API가 필요없습니다.

```tsx
export const metadata = {
  title: "Home",
};
const URL = "https://movie.com";

async function getMovies() {
  const response = await fetch(URL).then((response) => response.json());
  return response;
}

export default async function HomePage() {
  const movies = await getMovies();
  return <div>{JSON.stringify(movies)}</div>;
}
```

### [3] 장점
서버 컴포넌트를 사용하면 fetch 된 URL을 자동으로 캐싱시켜줍니다. 즉, 첫번째 fetch만 API에 요청합니다.
이처럼 로딩은 있지만 매우 빠르게 느껴지는 이유는 서버 컴포넌트에서 NextJS fetch 한 것을 기억하기 때문입니다.

### [4] loading.tsx
만약 사용자가 페이지에 도착하는 순간 데이터가 fetch 되기 전에 보여주고 싶은 것이 있다면 어떻게 해야할까요?
- NextJS loading.tsx 파일을 통해 이를 제공하고 있습니다.
- page, layout, not-fount 와 같이 파일 이름을 꼭 지켜주어야 합니다.
- 개발자는 loading을 코드로 관리할 필요없이 해당 파일을 통해 Loading을 제공합니다.



